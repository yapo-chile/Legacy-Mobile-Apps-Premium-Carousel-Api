package repository

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"regexp"
	"strconv"
	"strings"

	"github.mpi-internal.com/Yapo/premium-carousel-api/pkg/domain"
	"github.mpi-internal.com/Yapo/premium-carousel-api/pkg/usecases"
)

// AdRepo implements the repository interface and gets ads from search-ms
type AdRepo struct {
	handler         HTTPHandler
	regionsConf     Config
	path            string
	maxAdsToDisplay int
}

// MakeAdRepository returns a fresh instance of AdRepo
func MakeAdRepository(handler HTTPHandler, regionsConf Config, path string, maxAdsToDisplay int) usecases.AdRepository {
	return &AdRepo{
		handler:         handler,
		path:            path,
		regionsConf:     regionsConf,
		maxAdsToDisplay: maxAdsToDisplay,
	}
}

// SearchInput object to recieve search-ms input data type
type SearchInput map[string]interface{}

// GetUserAds gets user active ads list from search-ms. The pagination starts
// from page 1, also page 0 means page 1
func (repo *AdRepo) GetUserAds(userID string, cpConfig usecases.CpConfig) (domain.Ads, error) {
	query := cpConfig.CustomQuery
	limit := repo.makeLimit(cpConfig)
	exclude := repo.makeExclude(cpConfig)
	priceRange := repo.makePriceRange(cpConfig)
	sorting, random := repo.makeSorting(cpConfig)
	categoryFilter := repo.makeCategoryFilter(cpConfig)

	key := fmt.Sprintf("%s lim", random)
	value := fmt.Sprintf("%d %s %s %s %s user_id:%s",
		limit,
		sorting,
		priceRange,
		exclude,
		categoryFilter,
		strings.Join([]string{userID, "*:*", query}, " "))

	fmt.Printf("key-val %+s: %s\n", key, value)
	request := repo.handler.NewRequest().
		SetMethod("POST").
		SetPath(repo.path).
		SetBody(SearchInput{"searchKey": "user_id", "limit": -1,
			"values": map[string]string{key: value}})

	response, err := repo.handler.Send(request)
	if err == nil {
		var adResult usecases.SearchResponse
		if err := json.Unmarshal([]byte(fmt.Sprintf("%s", response)),
			&adResult); err != nil {
			return domain.Ads{}, fmt.Errorf("There was an error "+
				"retrieving ads info from search-ms: %+v. \n specified arguments: "+
				"userID: %s", err, userID)
		}
		ads := repo.parseToAds(adResult)
		if len(ads) == 0 {
			return domain.Ads{}, fmt.Errorf("The specified "+
				"userID: %s don't return results from search-ms",
				userID)
		}
		if len(ads) < limit && cpConfig.FillGapsWithRandom {
			ads = repo.fillGapsWithRandom(userID, (limit - len(ads)), ads)
		}
		return ads, nil
	}
	return domain.Ads{}, fmt.Errorf("There was an error retrieving ads info: %+v", err)
}

func (repo *AdRepo) fillGapsWithRandom(userID string, delta int, ads domain.Ads) domain.Ads {
	exclude := []string{}
	for _, ad := range ads {
		exclude = append(exclude, ad.ID)
	}
	extraAds, _ := repo.GetUserAds(userID, usecases.CpConfig{
		Sorting:            "random",
		Exclude:            exclude,
		FillGapsWithRandom: false,
		Limit:              delta,
	})
	ads = append(ads, extraAds...)
	for i := range ads {
		j := rand.Intn(i + 1)
		ads[i], ads[j] = ads[j], ads[i]
	}
	return ads
}

func (repo *AdRepo) makeExclude(cpConfig usecases.CpConfig) string {
	if len(cpConfig.Exclude) != 0 {
		return fmt.Sprintf("NOT list_id:%s", strings.Join(cpConfig.Exclude, ","))
	}
	return ""
}

func (repo *AdRepo) makePriceRange(cpConfig usecases.CpConfig) string {
	if cpConfig.PriceRangeFrom > 0 && cpConfig.PriceRangeTo > 0 {
		return fmt.Sprintf("price:%d-%d", cpConfig.PriceRangeFrom, cpConfig.PriceRangeTo)
	}
	if cpConfig.PriceRangeFrom == 0 && cpConfig.PriceRangeTo > 0 {
		return fmt.Sprintf("price:-%d", cpConfig.PriceRangeTo)
	}
	if cpConfig.PriceRangeFrom > 0 && cpConfig.PriceRangeTo == 0 {
		return fmt.Sprintf("price:%d-", cpConfig.PriceRangeFrom)
	}
	return ""
}

func (repo *AdRepo) makeLimit(cpConfig usecases.CpConfig) int {
	if cpConfig.Limit > 0 {
		return cpConfig.Limit
	}
	return repo.maxAdsToDisplay
}

func (repo *AdRepo) makeSorting(cpConfig usecases.CpConfig) (string, string) {
	switch cpConfig.Sorting {
	case "date":
		return "sort:-+:date:-", ""
	case "price":
		return "sort:+-:price:-", ""
	case "random":
		return "", "R"
	default:
		return "", ""
	}
}

func (repo *AdRepo) makeCategoryFilter(cpConfig usecases.CpConfig) string {
	if len(cpConfig.Categories) != 0 {
		return fmt.Sprintf("category:%s", strings.Join(cpConfig.Categories, ","))
	}
	return ""
}

var notAlphaNumbericRegex, _ = regexp.Compile("[^a-zA-Z0-9]+")
var specialCases = strings.NewReplacer("á", "a", "é", "e", "í", "i", "ó", "o",
	"ú", "u", "'", "", "ñ", "n")

func (repo *AdRepo) parseToAds(response usecases.SearchResponse) domain.Ads {
	ads := domain.Ads{}
	for _, values := range response {
		for _, ad := range values {
			price, _ := strconv.ParseFloat(ad.Price, 64)
			unitOfAccount, _ := strconv.ParseFloat(ad.UnitOfAccount, 64)
			regionKey := fmt.Sprintf("region.%s.link", ad.RegionID)
			regionName := repo.regionsConf.Get(regionKey)
			ads = append(ads,
				domain.Ad{
					ID:            ad.ListID,
					CategoryID:    ad.CategoryID,
					Subject:       ad.Subject,
					Price:         price,
					UnitOfAccount: unitOfAccount,
					Currency:      ad.Currency,
					Image: domain.Image{
						Full:   ad.Image.MainImage,
						Medium: ad.Image.Thumbli,
						Small:  ad.Image.Thumbs,
					},
					URL: "/" + strings.Join(
						[]string{
							notAlphaNumbericRegex.ReplaceAllString(
								specialCases.Replace(strings.ToLower(regionName)), "_"),
							notAlphaNumbericRegex.ReplaceAllString(
								specialCases.Replace(strings.ToLower(ad.Subject)), "_") +
								"_" + ad.ListID,
						},
						"/",
					),
				},
			)
		}
	}
	return ads
}
